// This file is auto-generated from markdown files in docs/
// Do not edit manually - run 'pnpm run process-blog' to regenerate

export interface BlogPost {
  id: string;
  title: string;
  excerpt: string;
  content: string;
  date: string;
  author: string;
  readTime: string;
  category: string;
  tags: string[];
}

export const blogPosts: BlogPost[] = [
  {
    "id": "why-privacy-markets-essential-rwa",
    "title": "Why Privacy Markets Are Essential for RWA Trading",
    "excerpt": "How private execution with on-chain settlement protects institutional traders from information leakage in tokenized real-world asset markets.",
    "content": "# Why Privacy Markets Are Essential for RWA Trading\n\n![DuskPool N Stellar](/blog-assets/duskpoolnstellar.png)\nWhen large trades happen in public markets, everyone sees the intent—and the price often moves before the trade is done. That's why private venues exist in traditional finance: to allow big orders to be executed without broadcasting the size or direction to the market.\n\nAs tokenized real-world assets (RWAs) grow, this problem gets bigger. RWAs are often less liquid, larger in size, and more sensitive to timing and disclosure. At the same time, institutional participation is accelerating, bringing real-world trading behavior on-chain.\n\nThat creates a clear need: **private execution with on-chain settlement**.\n\n- **Private execution** means orders can be matched without exposing intent.\n- **On-chain settlement** means the trade can still be final, auditable, and fair once it clears.\n\nThis is why we believe privacy markets are essential for RWA trading. They protect participants from information leakage, reduce market impact, and make it possible to move real size without destabilizing the market.\n\n---\n\n## Why Build This on Stellar?\n\nDuskPool is building on Stellar because the network is now explicitly enabling zero-knowledge (ZK) applications through **Protocol 25 (X-Ray)**. X-Ray introduces native cryptographic primitives to Soroban that make privacy-preserving markets practical on-chain.\n\nTwo upgrades matter most:\n\n1. **BN254 host functions** enable efficient on-chain verification of zk-SNARK proofs.\n2. **Poseidon and Poseidon2 host functions** provide ZK-friendly hashing for commitments, Merkle trees, and nullifiers—core building blocks of private trading systems.\n\n---\n\n## ERC-3643 and Compliant RWAs\n\nWe also like that the Stellar Development Foundation joined the **ERC-3643 Association**, a standard focused on compliant, permissioned tokenization for RWAs. SDF's participation signals a serious commitment to interoperability, compliance, and institutional-grade asset issuance—which aligns with the market structure DuskPool is building.\n\n---\n\n## The Future of RWAs\n\n![assets-to-token](/blog-assests/realtotoken.png)\nThe future of RWAs isn't just tokenization—it's **market structure**.\n\nDuskPool is building a privacy market layer so institutions can trade at size without leaking intent, while still settling transparently on-chain. That balance is what real-world adoption needs—and it's why we chose Stellar.\n\n---\n\n> Ready to trade RWAs with privacy guarantees? [Explore the terminal](https://duskpools.xyz) and connect your wallet.",
    "date": "2026-02-08",
    "author": "Duskpool Team",
    "readTime": "5 min read",
    "category": "Insights",
    "tags": [
      "privacy",
      "rwa",
      "stellar",
      "market-structure"
    ]
  },
  {
    "id": "whitepaper",
    "title": "Duskpool Whitepaper: RWA Dark Pool on Stellar",
    "excerpt": "A full-stack technical overview of Duskpool’s private RWA trading architecture on Stellar, from commitments to on-chain ZK settlement.",
    "content": "# RWA Dark Pool on Stellar\n\n## Executive Summary\n\nDuskpool is a private trading venue for tokenized real‑world assets (RWAs) on Stellar. It allows compliant institutions to execute large trades without leaking sensitive order details, while still settling on‑chain with cryptographic proof of correctness. The core idea is simple: commitments keep order details hidden, a matching engine finds compatible trades off‑chain, and zero‑knowledge proofs (ZK) allow on‑chain settlement without exposing price, size, or identity.\n\nOur system is built around Stellar’s X‑Ray (Protocol 25) cryptographic primitives. These native primitives make it practical to verify Groth16 proofs on‑chain using BN254 pairings and Poseidon2 hashing, enabling verifiable privacy without requiring a separate chain or trusted middlemen.\n\nThis whitepaper explains the full stack: the cryptographic primitives, the ZK circuit design, the smart contract roles, the off‑chain matching and proof generation pipeline, and the trust model that keeps the system robust under adversarial conditions.\n\n## Problem\n\nInstitutional RWA trading today faces a structural conflict between transparency and privacy.\n\n**Market leakage**  \n> Public order books reveal order size, price intent, and trading strategy. This exposes participants to front‑running and adverse selection, discourages block trades, and widens spreads.\n\n**Compliance constraints**  \n> RWAs require strict KYC/AML and eligibility controls, yet traditional private venues are closed and slow. Public networks are fast but transparent, creating a compliance vs. privacy trade‑off.\n\n**Operational friction**  \n> Settlement across bilateral agreements is slow, with fragmented custody and weak interoperability. Institutions need programmable settlement that can enforce policy and privacy simultaneously.\n\nA modern RWA market must keep trading details private while preserving provable correctness, regulated access, and on‑chain settlement finality.\n\n## Solution Overview\n\nWe provide a private market layer on Stellar for RWA tokens. The system delivers confidentiality and compliance by splitting the workflow into three phases.\n\n**1. Commit**  \n> Traders submit cryptographic commitments of their orders to the on‑chain orderbook. Commitments are binding and hiding, so the market can index orders without revealing price or size.\n\n**2. Match**  \n> An off‑chain matching engine compares full order details privately, identifies compatible trades, and prepares a settlement proposal.\n\n**3. Prove & Settle**  \n> A zero‑knowledge proof is generated to show that both traders are whitelisted and that commitments are consistent with the agreed trade. The settlement contract verifies the proof on‑chain and atomically swaps escrowed assets.\n\n### What’s Public vs Private\n\n| Public | Private |\n| :--- | :--- |\n| Commitment hashes | Trader identity hashes |\n| Asset identifier hash | Order quantity and price |\n| Whitelist Merkle root | Nonce/secret values |\n| Proof validity | Full match details |\n| Settlement execution results | |\n\nThis architecture keeps market data private while preserving verifiability and compliance.\n\n## Architecture & Flow\n\n### Components\n\n**Registry contract**  \n> Maintains the whitelist of eligible participants and the list of tradable RWA assets. The whitelist is represented as a Merkle tree root, which can be used inside ZK proofs. The contract also stores the verifier address and verification key reference used by settlement.\n\n**Orderbook contract**  \n> Stores commitment‑only orders. Traders publish commitments and metadata such as asset address and side. No sensitive parameters are revealed. Matches are recorded so that settlement can be performed later.\n\n**Settlement contract**  \n> Holds escrow balances, verifies ZK proofs, enforces anti‑replay via nullifiers, and performs atomic swaps of escrowed assets. It is the final arbiter of whether a trade can settle.\n\n**Verifier contract**  \n> A Groth16 verifier using BN254 pairings, enabled by Stellar X‑Ray primitives. It parses the verification key, proof, and public signals and returns a boolean validity result.\n\n**Matching engine**  \n> An off‑chain service that receives full order details (encrypted in production), matches orders by price‑time priority, and orchestrates proof generation.\n\n**Prover**  \n> Generates ZK proofs that bind commitments, whitelist membership, and trade parameters together in a single settlement proof.\n\n![system overview](/blog-assets/systemoverview.png)\n\n### End‑to‑End Flow\n\n1. **Whitelist & asset registration**\nThe admin registers participants and assets in the registry. The whitelist root is updated on‑chain.\n\n2. **Escrow funding**\nTraders deposit RWA tokens and payment tokens into the settlement contract escrow.\n\n3. **Commitment submission**\nTraders submit order commitments to the orderbook contract.\n\n4. **Private matching**\nThe matching engine receives full order details, matches buy and sell orders, and selects trade terms.\n\n5. **Proof generation**\nThe prover constructs a ZK proof that:\n- Buyer and seller are whitelisted\n- Commitments correspond to the matched trade parameters\n- The nullifier is correctly computed\n\n6. **On‑chain settlement**\nThe settlement contract verifies the proof, checks the nullifier has not been used, and atomically swaps escrowed assets.\n\n![data flow](/blog-assets/dataflow.png)\n\n## Stellar X‑Ray Cryptography (Protocol 25)\n\nProtocol 25 introduced native cryptographic primitives to Stellar that make ZK verification practical on‑chain. Duskpool relies on two key primitives.\n\n**BN254 elliptic curve operations (CAP‑0074)**\n\nThese enable Groth16 verification directly in smart contracts via:\n> - `bn254_g1_add`\n> - `bn254_g1_mul`\n> - `bn254_multi_pairing_check`\n\n**Poseidon2 hash (CAP‑0075)**\n\nA ZK‑friendly hash over the BN254 scalar field, used both in circuits and on‑chain commitments.\n\nBy using these primitives, Duskpool can verify proofs without external dependencies, which keeps settlement deterministic, cheap, and fully on‑chain.\n\n## Mathematical Model\n\nWe treat Poseidon and BN254 as primitives provided by Stellar’s X‑Ray cryptographic host functions. We do not derive them; we use them to enforce privacy and correctness.\n\n### 1. Cryptographic Primitives\n\nPoseidon hash (ZK‑friendly, field‑based):\n\n$$\nH_P : \\mathbb{F}_p^t \\to \\mathbb{F}_p\n$$\n\nBN254 elliptic curve (pairing‑friendly):\n\n$$\nE(\\mathbb{F}_p): y^2 = x^3 + 3\n$$\n\nBilinear pairing:\n\n$$\ne : G_1 \\times G_2 \\to G_T\n$$\n\n### 2. Order Commitment\n\nEach order is encoded into a commitment hash:\n\n$$\nC = H_P(a, s, q, p, n, k)\n$$\n\nWhere:\n- `a` = asset hash\n- `s` = side (0 = buy, 1 = sell)\n- `q` = quantity\n- `p` = price\n- `n` = nonce\n- `k` = secret\n\nThis makes the order binding and hiding. Anyone can see `C`, but only the trader can reveal the values that produced it.\n\n### 3. Whitelist Membership (Merkle Proof)\n\nEach participant proves KYC membership without revealing their identity:\n\n$$\nR = \\mathrm{MerkleRoot}(leaf, \\pi)\n$$\n\nWhere:\n- `R` = whitelist root (public)\n- `leaf` = participant ID hash\n- `\\pi` = Merkle path (private)\n\nThe proof shows that `leaf` is included in the tree that produced `R`.\n\n### 4. Match Validity\n\nThe matching engine enforces compatibility:\n\n$$\np_{\\text{buy}} \\ge p_{\\text{sell}}\n$$\n\n$$\np_{\\text{exec}} = \\frac{p_{\\text{buy}} + p_{\\text{sell}}}{2}\n$$\n\nThe execution price is derived from both orders and is included in the proof.\n\n### 5. Nullifier (Anti‑Replay)\n\nTo prevent double‑settlement:\n\n$$\nN = H_P(C_{\\text{buy}}, C_{\\text{sell}}, q, k_{\\text{buy}} + k_{\\text{sell}})\n$$\n\nIf `N` appears on‑chain more than once, the settlement is rejected.\n\n### 6. Proof Verification (BN254 Pairing)\n\nThe on‑chain verifier checks Groth16 validity using BN254 pairings:\n\n$$\ne(A, B) \\cdot e(-\\alpha, \\beta) \\cdot e\\left(-\\sum_i x_i \\cdot IC_i, \\gamma\\right) \\cdot e(-C, \\delta) = 1\n$$\n\nThis equation validates that the proof corresponds to the stated public signals and is cryptographically sound.\n\n### 7. On‑Chain Escrow Invariants\n\nEscrow balances follow simple accounting constraints:\n\n$$\n\\mathrm{Escrow} = \\mathrm{Deposits} - \\mathrm{Withdrawals} - \\mathrm{Locked} + \\mathrm{Unlocked}\n$$\n\nSettlement executes only if balances remain non‑negative:\n\n$$\n\\mathrm{Seller}(\\text{asset}) \\ge q\n$$\n\n$$\n\\mathrm{Buyer}(\\text{payment}) \\ge p_{\\text{exec}} \\cdot q\n$$\n\n## ZK Circuit Design\n\nThe settlement circuit proves that a trade is valid without revealing order details. It checks:\n> - Both parties are on the whitelist Merkle tree\n> - Commitments correspond to the claimed order parameters\n> - Trade terms (asset, quantity, price) are consistent\n> - A nullifier is computed to prevent replay\n\n### Circuit Public Inputs\n\nThese values are visible on‑chain and are used by the verifier:\n> - `buyCommitment`\n> - `sellCommitment`\n> - `assetHash`\n> - `matchedQuantity`\n> - `executionPrice`\n> - `whitelistRoot`\n\n### Circuit Private Inputs\n\nThese values are hidden inside the proof:\n> - Buyer and seller ID hashes\n> - Merkle paths for whitelist membership\n> - Order secrets and nonces\n\n### Circuit Capacity\n\nThe whitelist Merkle tree depth is 20, supporting up to 1,048,576 participants. This allows large institutional pools without rebuilding the tree.\n\n### Circuit Output\n\nThe circuit outputs a nullifier hash. The settlement contract rejects any transaction that reuses the same nullifier, preventing double‑settlement.\n\n## Smart Contract Responsibilities\n\n### Registry Contract\n\nThe registry contract is the on‑chain source of truth for eligibility and assets. It:\n> - Stores the current whitelist Merkle root\n> - Manages participant registration and KYC expiry\n> - Manages registered RWA assets\n> - Stores the verifier address and eligibility verification key\n\n### Orderbook Contract\n\nThe orderbook stores commitments and minimal metadata. It:\n> - Accepts commitment submissions\n> - Marks orders as matched or cancelled\n> - Ensures asset compatibility for matches\n> - Records match data for settlement\n\n### Settlement Contract\n\nThe settlement contract is the execution layer. It:\n> - Holds escrowed assets\n> - Verifies ZK proofs for settlement\n> - Enforces nullifier uniqueness\n> - Swaps assets atomically if proof is valid\n\n### Verifier Contract\n\nThe verifier contract is a generic BN254 Groth16 verifier. It:\n> - Parses the verification key and proof bytes\n> - Applies pairing checks using X‑Ray primitives\n> - Returns a boolean validity result\n\n![contract overview](/blog-assets/contractoverview.png)\n## Off‑Chain Matching Engine\n\nThe matching engine runs off‑chain to find compatible orders while preserving privacy. It:\n> - Maintains an in‑memory orderbook per asset\n> - Matches orders when `buy price >= sell price`\n> - Uses midpoint pricing for execution\n> - Supports partial fills\n> - Rejects expired orders\n\nIn production, order parameters are provided to the matching engine in encrypted form. Only commitments are posted on‑chain, so the public network never sees order details.\n\n## Proof Generation Pipeline\n\nThe prover library is responsible for all cryptographic operations required to produce a settlement proof.\n\n### Order Commitment Generation\n\nA trader creates a commitment using Poseidon with the order parameters and a secret nonce. The output is the commitment hash and the secret data needed for later settlement.\n\n### Whitelist Tree Construction\n\nThe prover builds a Merkle tree from participant ID hashes and produces Merkle proofs for any participant that will trade.\n\n### Settlement Proof Generation\n\nThe settlement proof binds:\n> - The buy and sell commitments\n> - The whitelist membership proofs\n> - The execution price and quantity\n> - The nullifier\n\nThe output is formatted for Soroban:\n> - `proofBytes` (A, B, C points serialized)\n> - `signalsBytes` (public signals serialized)\n\nThese are passed directly to the settlement contract.\n\n## Operational Notes\n\n### Trusted Setup and Powers of Tau\n\nThe Groth16 circuit requires a trusted setup. A Powers of Tau file is used to generate the proving key and verification key. A production setup uses a larger `ptau` file for the full circuit constraints.\n\n### Verification Key Export\n\nThe verification key is exported into a hex byte format and deployed to the settlement contract. This ensures that the on‑chain verifier can validate proofs generated by the off‑chain prover.\n\n## Security & Trust Assumptions\n\nThe security of the system relies on:\n> 1. Groth16 soundness on BN254\n> 2. Honest whitelist management by the registry admin\n> 3. Off‑chain matching engine cannot force settlement; it only proposes matches\n> 4. On‑chain verification rejects invalid proofs and replayed trades\n\nEven if the matching engine is compromised, it cannot settle invalid trades because the settlement contract enforces proof validity and nullifier uniqueness.\n\n## Gas Costs and Verification\n\nOn Stellar (via Protocol 25), BN254 operations are native:\n\n| Operation | Gas Cost |\n|-----------|----------|\n| Poseidon Hash | ~2,000 |\n| Groth16 Verify | ~200,000 |\n| Full Match Verification | ~250,000 |\n\nThis is significantly cheaper than Ethereum L1 verification, making ZK‑verified trading economically viable.\n\n## What We Enable\n\n**Institutional privacy**  \n> Traders can negotiate and execute without leaking order details to the public network.\n\n**Compliance by design**  \n> Whitelist membership is proven in zero‑knowledge; only eligible participants can settle.\n\n**RWA liquidity**  \n> Private execution enables larger block trades with reduced market impact.\n\n**Atomic on‑chain settlement**  \n> Escrowed assets move only after proof verification, reducing counterparty risk.\n\n**Composable infrastructure**  \n> The system integrates with Stellar’s native assets and token contracts, enabling regulated issuers to list RWAs without building a new chain.\n\n## Looking Forward\n\nWe are actively exploring:\n> - **Recursive proofs** for batch settlement (PLONK‑based)\n> - **Threshold FHE** for encrypted order matching\n> - **Cross‑chain bridges** with ZK state verification\n\nThe goal is a trading system where privacy is the default, not an afterthought.\n\n---\n\n> For the complete circuit implementations, see our [GitHub repository](https://github.com/duskpool/circuits).",
    "date": "2026-02-08",
    "author": "Duskpool Team",
    "readTime": "8 min read",
    "category": "Whitepaper",
    "tags": [
      "whitepaper",
      "stellar",
      "rwa",
      "privacy",
      "zk-proofs"
    ]
  },
  {
    "id": "introducing-duskpool",
    "title": "Introducing Duskpool: Private RWA Trading on Stellar",
    "excerpt": "A zero-knowledge dark pool for institutional-grade real-world asset trading on the Stellar network.",
    "content": "# Introducing Duskpool\n\nTraditional dark pools solved a real problem: institutional traders needed a way to execute large orders without moving the market against them. But they came with a cost—opacity that bred distrust and, occasionally, abuse.\n\nDuskpool takes the core value proposition of dark pools and rebuilds it with cryptographic guarantees. Every trade is verifiable. Every settlement is atomic. And your order details remain private until execution.\n\n## The Problem with Transparent Markets\n\nWhen you place a large order on a public order book, you signal your intentions to every other participant. Algorithms front-run your trades. Market makers adjust their quotes. By the time your order fills, you've paid an implicit tax to everyone who saw you coming.\n\nFor institutional traders dealing in real-world assets—treasury bills, tokenized real estate, commodity-backed tokens—this information leakage is unacceptable.\n\n## How Duskpool Works\n\nDuskpool uses Protocol 25's zero-knowledge proof capabilities on Stellar to create a trading environment where:\n\n1. **Order Privacy**: Your buy/sell intentions remain hidden until matched\n2. **Atomic Settlement**: Trades execute in a single transaction—no counterparty risk\n3. **Regulatory Compliance**: KYC verification via Merkle tree proofs, without revealing identity on-chain\n\nThe math behind this is elegant. When you place an order, you submit a cryptographic commitment:\n\n$$\nC = \\text{Poseidon}(asset, amount, price, nonce)\n$$\n\nThis commitment reveals nothing about your order. But when two orders match, the ZK-verifier contract can confirm validity without exposing the underlying data.\n\n## Settlement Flow\n\nThe settlement process uses a matching engine that operates on encrypted order data:\n\n```typescript\ninterface EncryptedOrder {\n  commitment: Field;\n  proof: Groth16Proof;\n  timestamp: number;\n}\n\n// Orders are matched based on commitment compatibility\n// without revealing price or quantity\nfunction matchOrders(buy: EncryptedOrder, sell: EncryptedOrder): Match | null {\n  // ZK verification ensures orders are valid and compatible\n  const isValid = verifyMatchProof(buy.proof, sell.proof);\n  if (!isValid) return null;\n\n  return { buyer: buy.commitment, seller: sell.commitment };\n}\n```\n\n## Supported Assets\n\nAt launch, Duskpool supports:\n\n- **US Treasury Bills** (tokenized via regulated issuers)\n- **PAXG** (gold-backed tokens)\n- **Select Commercial Real Estate** tokens\n\nAll assets are issued by partners with proper regulatory frameworks on the Stellar network.\n\n## What's Next\n\nWe're building Duskpool in public. The contracts are audited. The matching engine is live on testnet. And we're onboarding our first institutional partners.\n\nIf you're interested in trading RWAs with privacy guarantees, [connect your wallet](/trade) and explore the terminal.\n\n---\n\n> Duskpool is currently in testnet. All trades are simulated with test assets.",
    "date": "2026-02-06",
    "author": "Duskpool Team",
    "readTime": "6 min read",
    "category": "Protocol",
    "tags": [
      "announcement",
      "stellar",
      "privacy",
      "rwa"
    ]
  },
  {
    "id": "zk-proofs-explained",
    "title": "Zero-Knowledge Proofs in RWA Trading",
    "excerpt": "A technical deep-dive into how Duskpool uses ZK proofs to enable private trading of real-world assets.",
    "content": "# Zero-Knowledge Proofs in RWA Trading\n\nZero-knowledge proofs allow you to prove something is true without revealing *why* it's true. In the context of trading, this means proving your order is valid without revealing its price, quantity, or direction.\n\nThis isn't just a nice-to-have for privacy. It's a fundamental shift in how markets can operate.\n\n## The Core Idea\n\nConsider a simple statement: \"I want to buy 100 treasury bills at $98 each.\"\n\nIn a ZK system, you can prove:\n- You have sufficient collateral locked\n- Your order conforms to protocol rules\n- You're authorized to trade (KYC verified)\n\nAll without revealing the `100`, the `$98`, or even that you're buying rather than selling.\n\n## The Mathematics\n\nDuskpool uses Groth16 proofs over the BN254 curve—the same proving system used by Ethereum's zkSync and Polygon's zkEVM. The proofs are small (128 bytes) and verification is fast enough for on-chain execution.\n\n### Commitment Scheme\n\nOrders are hidden behind Poseidon hash commitments. Poseidon is a ZK-friendly hash function optimized for arithmetic circuits:\n\n$$\nC = \\text{Poseidon}(pk, asset\\_id, amount, price, side, nonce)\n$$\n\nWhere:\n- $pk$ is the trader's public key\n- $asset\\_id$ identifies the token pair\n- $amount$ is the order quantity\n- $price$ is the limit price\n- $side \\in \\{0, 1\\}$ indicates buy or sell\n- $nonce$ prevents replay attacks\n\n### Match Verification\n\nWhen two orders potentially match, the ZK circuit verifies:\n\n$$\n\\text{verify}(C_{buy}, C_{sell}, \\pi) =\n\\begin{cases}\n1 & \\text{if } price_{buy} \\geq price_{sell} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n\nThe proof $\\pi$ demonstrates the match is valid without revealing the actual prices.\n\n## Circuit Architecture\n\nOur Circom circuits are structured around three main components:\n\n```circom\ntemplate OrderCommitment() {\n    signal input pk;\n    signal input assetId;\n    signal input amount;\n    signal input price;\n    signal input side;  // 0 = buy, 1 = sell\n    signal input nonce;\n\n    signal output commitment;\n\n    // Poseidon hash with 6 inputs\n    component hasher = Poseidon(6);\n    hasher.inputs[0] <== pk;\n    hasher.inputs[1] <== assetId;\n    hasher.inputs[2] <== amount;\n    hasher.inputs[3] <== price;\n    hasher.inputs[4] <== side;\n    hasher.inputs[5] <== nonce;\n\n    commitment <== hasher.out;\n}\n\ntemplate MatchVerifier() {\n    signal input buyCommitment;\n    signal input sellCommitment;\n    signal input buyPrice;\n    signal input sellPrice;\n\n    // Verify price compatibility\n    signal priceDiff;\n    priceDiff <== buyPrice - sellPrice;\n\n    // buyPrice >= sellPrice (difference is non-negative)\n    component isValid = GreaterEqThan(64);\n    isValid.in[0] <== buyPrice;\n    isValid.in[1] <== sellPrice;\n\n    signal output valid;\n    valid <== isValid.out;\n}\n```\n\n## KYC Without Identity Exposure\n\nThe KYC system uses Merkle tree inclusion proofs. Authorized traders are added to a whitelist Merkle tree. To trade, you prove your address is in the tree without revealing which leaf you are:\n\n$$\n\\text{MerkleProof}(leaf, path, root) = 1 \\iff leaf \\in Tree(root)\n$$\n\nThis means the protocol knows you're authorized, but on-chain observers can't link your trades to your KYC identity.\n\n## Gas Costs and Verification\n\nOn Stellar (via Protocol 25), BN254 operations are native:\n\n| Operation | Gas Cost |\n|-----------|----------|\n| Poseidon Hash | ~2,000 |\n| Groth16 Verify | ~200,000 |\n| Full Match Verification | ~250,000 |\n\nThis is significantly cheaper than Ethereum L1 verification, making ZK-verified trading economically viable.\n\n## Security Considerations\n\nThe security of this system relies on:\n\n1. **Discrete Log Hardness**: Breaking BN254 would require solving ECDLP\n2. **Knowledge Soundness**: Groth16 proofs can only be generated with valid witnesses\n3. **Collision Resistance**: Poseidon commitments cannot be forged\n\nThe trusted setup for our circuits was performed with 50+ participants. Even if all but one colluded, the system remains secure.\n\n## Looking Forward\n\nWe're actively exploring:\n\n- **Recursive proofs** for batch settlement (PLONK-based)\n- **Threshold FHE** for encrypted order matching\n- **Cross-chain bridges** with ZK state verification\n\nThe goal is a trading system where privacy is the default, not an afterthought.\n\n---\n\n> For the complete circuit implementations, see our [GitHub repository](https://github.com/duskpool/circuits).",
    "date": "2026-02-05",
    "author": "Duskpool Team",
    "readTime": "10 min read",
    "category": "Technical",
    "tags": [
      "zk-proofs",
      "cryptography",
      "technical",
      "groth16"
    ]
  }
];

export function getBlogPostById(id: string): BlogPost | undefined {
  return blogPosts.find(post => post.id === id);
}

export function searchBlogPosts(query: string): BlogPost[] {
  const lowerQuery = query.toLowerCase();
  return blogPosts.filter(post =>
    post.title.toLowerCase().includes(lowerQuery) ||
    post.content.toLowerCase().includes(lowerQuery) ||
    post.excerpt.toLowerCase().includes(lowerQuery) ||
    post.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
  );
}
